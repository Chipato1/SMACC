\hypertarget{namespaceregex__template}{}\section{regex\+\_\+template Namespace Reference}
\label{namespaceregex__template}\index{regex\+\_\+template@{regex\+\_\+template}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{classregex__template_1_1TypeInfo}{Type\+Info}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
def \hyperlink{namespaceregex__template_a13dc0843d7416b24f99bcffd147c3d79}{get\+Root\+Type\+Info} (\hyperlink{namespaceregex__template_a5e23ed7a5dae7db8eb3cdae8fb3e3230}{inputtext})
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
string \hyperlink{namespaceregex__template_a5e23ed7a5dae7db8eb3cdae8fb3e3230}{inputtext} = \char`\"{}smacc\+::transition$<$Ev1$<$Lidar\+Sensor$<$sensor\+\_\+msgs\+::\+Laser\+Scan, std\+::allocator$<$none$>$$>$, E\+V\+T\+AG$>$, State1, T\+AG$>$\char`\"{}
\item 
\hyperlink{namespaceregex__template_a0b583a61fb8c99797bfa366fda2f86a2}{roottypeinfo} = \hyperlink{namespaceregex__template_a13dc0843d7416b24f99bcffd147c3d79}{get\+Root\+Type\+Info}(\hyperlink{namespaceregex__template_a5e23ed7a5dae7db8eb3cdae8fb3e3230}{inputtext})
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{regex\+\_\+template@{regex\+\_\+template}!get\+Root\+Type\+Info@{get\+Root\+Type\+Info}}
\index{get\+Root\+Type\+Info@{get\+Root\+Type\+Info}!regex\+\_\+template@{regex\+\_\+template}}
\subsubsection[{\texorpdfstring{get\+Root\+Type\+Info(inputtext)}{getRootTypeInfo(inputtext)}}]{\setlength{\rightskip}{0pt plus 5cm}def regex\+\_\+template.\+get\+Root\+Type\+Info (
\begin{DoxyParamCaption}
\item[{}]{inputtext}
\end{DoxyParamCaption}
)}\hypertarget{namespaceregex__template_a13dc0843d7416b24f99bcffd147c3d79}{}\label{namespaceregex__template_a13dc0843d7416b24f99bcffd147c3d79}


Definition at line 13 of file regex\+\_\+template.\+py.



References smacc.\+replace\+\_\+back().


\begin{DoxyCode}
13 \textcolor{keyword}{def }\hyperlink{namespaceregex__template_a13dc0843d7416b24f99bcffd147c3d79}{getRootTypeInfo}(inputtext):
14     ok = \textcolor{keyword}{False}
15     typecount = 0
16     typesdict = \{\}
17     originalinputtext = inputtext
18 
19     \textcolor{comment}{# this loop flatterns the template type tree}
20     \textcolor{keywordflow}{while} \textcolor{keywordflow}{not} ok:
21         simpletypeRE = \textcolor{stringliteral}{r"[^<>,\(\backslash\)s]+<[^<>]+>"}
22         \textcolor{keywordflow}{print} (\textcolor{stringliteral}{"input: "} + inputtext)
23 
24         matches = [m \textcolor{keywordflow}{for} m \textcolor{keywordflow}{in} enumerate(re.finditer(simpletypeRE, inputtext))]
25         \textcolor{keywordflow}{if} len(matches) == 0:
26             \textcolor{keywordflow}{if} len(typesdict) == 0:
27                 typekey = \textcolor{stringliteral}{"$T"} + str(typecount)
28                 typesdict[typekey] = inputtext
29             \textcolor{keywordflow}{break}
30 
31         \textcolor{keywordflow}{for} i, m \textcolor{keywordflow}{in} matches:
32             tstr = m.group(0)
33 
34             typekey = \textcolor{stringliteral}{"$T"} + str(typecount)
35             inputtext = inputtext.replace(tstr, typekey)
36             print(\textcolor{stringliteral}{"updating input text: "} + inputtext)
37             typecount += 1
38             typesdict[typekey] = tstr
39 
40     \textcolor{comment}{# once the tree is flatterned we may get some template with flat types}
41     simpletypeRE = \textcolor{stringliteral}{r"<(.*)>"}
42 
43     allbasetypes = set()
44     \textcolor{keywordflow}{for} tkey \textcolor{keywordflow}{in} typesdict.keys():
45         flat = typesdict[tkey]
46         \textcolor{keywordflow}{print} flat
47         startindex = flat.index(\textcolor{stringliteral}{"<"})
48         flat = flat[startindex + 1:-1]
49         basetypes = [t.strip() \textcolor{keywordflow}{for} t \textcolor{keywordflow}{in} flat.split(\textcolor{stringliteral}{","})]
50         \textcolor{keywordflow}{for} b \textcolor{keywordflow}{in} basetypes:
51             \textcolor{keywordflow}{if} \textcolor{keywordflow}{not} \textcolor{stringliteral}{"$"} \textcolor{keywordflow}{in} b:
52                 allbasetypes.add(b)
53 
54     \textcolor{keywordflow}{for} b \textcolor{keywordflow}{in} allbasetypes:
55         typesdict[b] = b
56 
57     \textcolor{keyword}{def }\hyperlink{namespacesmacc_a72fcb6f2d23e716a772176e79495bc53}{replace\_back}(roottype, typesdict):
58         \textcolor{comment}{# replace back}
59         \textcolor{keywordflow}{while} \textcolor{stringliteral}{"$"} \textcolor{keywordflow}{in} roottype:
60             \textcolor{comment}{#print roottype}
61             \textcolor{keywordflow}{for} tkey \textcolor{keywordflow}{in} typesdict:
62                 tval = typesdict[tkey]
63                 roottype = roottype.replace(tkey, tval)
64 
65         \textcolor{keywordflow}{return} roottype
66 
67     types = []
68     \textcolor{keywordflow}{for} tkey \textcolor{keywordflow}{in} typesdict:
69         finaltype = \hyperlink{namespacesmacc_a72fcb6f2d23e716a772176e79495bc53}{replace\_back}(typesdict[tkey], typesdict)
70         t = \hyperlink{classregex__template_1_1TypeInfo}{TypeInfo}(tkey, typesdict[tkey], finaltype)
71         types.append(t)
72 
73         \textcolor{keywordflow}{print} t
74 
75     \textcolor{keywordflow}{print} (typesdict)
76     roottype = [t \textcolor{keywordflow}{for} t \textcolor{keywordflow}{in} types \textcolor{keywordflow}{if} t.finaltype == originalinputtext][0]
77 
78     \textcolor{keywordflow}{print} \textcolor{stringliteral}{"---------------------------------"}
79 
80     \textcolor{comment}{# fill template parameters}
81     \textcolor{keywordflow}{for} t \textcolor{keywordflow}{in} types:
82         \textcolor{keywordflow}{for} t2 \textcolor{keywordflow}{in} types:
83             \textcolor{keywordflow}{if} t2.tkey \textcolor{keywordflow}{in} t.codedtype:
84                 index = t.codedtype.index(t2.tkey)
85                 t.template\_parameters.append((index, t2))
86 
87         t.template\_parameters = [x[1] \textcolor{keywordflow}{for} x \textcolor{keywordflow}{in} sorted(
88             t.template\_parameters, key=\textcolor{keyword}{lambda} e: e[0])]
89 
90     \textcolor{keywordflow}{return} roottype
91     
\end{DoxyCode}


Here is the call graph for this function\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{namespaceregex__template_a13dc0843d7416b24f99bcffd147c3d79_cgraph}
\end{center}
\end{figure}




\subsection{Variable Documentation}
\index{regex\+\_\+template@{regex\+\_\+template}!inputtext@{inputtext}}
\index{inputtext@{inputtext}!regex\+\_\+template@{regex\+\_\+template}}
\subsubsection[{\texorpdfstring{inputtext}{inputtext}}]{\setlength{\rightskip}{0pt plus 5cm}string regex\+\_\+template.\+inputtext = \char`\"{}smacc\+::transition$<$Ev1$<$Lidar\+Sensor$<$sensor\+\_\+msgs\+::\+Laser\+Scan, std\+::allocator$<$none$>$$>$, E\+V\+T\+AG$>$, State1, T\+AG$>$\char`\"{}}\hypertarget{namespaceregex__template_a5e23ed7a5dae7db8eb3cdae8fb3e3230}{}\label{namespaceregex__template_a5e23ed7a5dae7db8eb3cdae8fb3e3230}


Definition at line 92 of file regex\+\_\+template.\+py.



Referenced by smacc\+::\+Type\+Info.\+get\+Non\+Templatetypename(), and smacc\+::\+Type\+Info.\+get\+Type\+Info\+From\+String().

\index{regex\+\_\+template@{regex\+\_\+template}!roottypeinfo@{roottypeinfo}}
\index{roottypeinfo@{roottypeinfo}!regex\+\_\+template@{regex\+\_\+template}}
\subsubsection[{\texorpdfstring{roottypeinfo}{roottypeinfo}}]{\setlength{\rightskip}{0pt plus 5cm}regex\+\_\+template.\+roottypeinfo = {\bf get\+Root\+Type\+Info}({\bf inputtext})}\hypertarget{namespaceregex__template_a0b583a61fb8c99797bfa366fda2f86a2}{}\label{namespaceregex__template_a0b583a61fb8c99797bfa366fda2f86a2}


Definition at line 93 of file regex\+\_\+template.\+py.

