\begin{TabularC}{2}
\hline
\rowcolor{lightgray}{\bf R\-O\-S Distro }&{\bf Travis Build Status  }\\\cline{1-2}
Indigo &  \\\cline{1-2}
Kinetic & \\\cline{1-2}
Melodic & \\\cline{1-2}
Master & \\\cline{1-2}
\end{TabularC}


\subsection*{Docker Containers}

\href{https://hub.docker.com/r/pabloinigoblasco/smacc/}{\tt !\mbox{[}Docker Automated build\mbox{]}(https\-://img.\-shields.\-io/docker/automated/pabloinigoblasco/smacc.\-svg?max\-Age=2592000)} \href{https://hub.docker.com/r/pabloinigoblasco/smacc/}{\tt !\mbox{[}Docker Pulls\mbox{]}(https\-://img.\-shields.\-io/docker/pulls/pabloinigoblasco/smacc.\-svg?max\-Age=2592000)} \href{https://registry.hub.docker.com/pabloinigoblasco/smacc/}{\tt !\mbox{[}Docker Stars\mbox{]}(https\-://img.\-shields.\-io/docker/stars/pabloinigoblasco/smacc.\-svg)}

\section*{S\-M\-A\-C\-C}

S\-M\-A\-C\-C is a R\-O\-S/\-C++ library designed to allow users to implement a broad variety of state machines in easy and systematic way \href{http://sce.uhcl.edu/helm/rationalunifiedprocess/process/modguide/md_stadm.htm}{\tt U\-M\-L State Charts} (A\-K\-A state machines). S\-M\-A\-C\-C is inspired by the \href{http://wiki.ros.org/smach}{\tt S\-M\-A\-C\-H R\-O\-S package} and it is built on top of \href{https://www.boost.org/doc/libs/1_53_0/libs/statechart/doc/index.html}{\tt Boost State\-Chart library}.

Probably the greatest strength of S\-M\-A\-C\-C is that the state machines you can develop with it are strictly based on the U\-M\-L Standard. This means that you have access to a clear and thoroughly studied and known approach to describe State Machines. This may be especially important in industrial environments.

The following image shows one example of state machine on the U\-M\-L standard and shows many of the concepts that can be implemented using S\-M\-A\-C\-C\-: 

 

\subsection*{Features}


\begin{DoxyItemize}
\item $\ast$$\ast$$\ast$\-Powered by R\-O\-S\-:$\ast$$\ast$$\ast$ S\-M\-A\-C\-C has been developed specifically to work with R\-O\-S. It is a c++ ros package that can be imported from any end-\/user application package.
\item $\ast$$\ast$$\ast$\-C++ language\-:$\ast$$\ast$$\ast$ R\-O\-S lacked the existence of a library to develop task-\/level state machine in c++. Many libraries in robotics are developed in c++ so that this may help during the integration of different libraries. In industrial development context are sometimes prefered the usage of c++ over Python, so that this tool may be a good choice.
\item $\ast$$\ast$$\ast$\-Static State Machine Checking\-:$\ast$$\ast$$\ast$ S\-M\-A\-C\-C inherits this from the statechart library. This helps the developer to check the consistence of the state machine in compile time (instead of runtime). In other words, it helps you to check if your state machine is well written.
\item $\ast$$\ast$$\ast$\-Component based architecture\-:$\ast$$\ast$$\ast$ S\-M\-A\-C\-C built-\/in funcionality is providedinside S\-M\-A\-C\-C Components that can be dinamically imported at runtime and stored in the local machine. The states only access to those components they are concerned. This enables the S\-M\-A\-C\-C application extend or improve the runtime behavior of the system.
\end{DoxyItemize}

\subsection*{Cannonical S\-M\-A\-C\-C applications}

The cannonical S\-M\-A\-C\-C applications are mobile robots (that may optionally have manipulators) that have to navigate around the environment and use some of the onboard tools. One example could be the P\-R2 Robot working in a factory navigating to some shelves with parcels, fetching them, and then navigating to some delivery point. Other example would include vaccum cleaners or mobile robots that must perform a systematic navigation on the ground executing some tool, in order to do that, S\-M\-A\-C\-C provide some navigation planners that can help on this task (see more on section R\-O\-S Integration).

\subsection*{R\-O\-S Integration}


\begin{DoxyItemize}
\item $\ast$$\ast$$\ast$\-Intensive use of R\-O\-S Action$\ast$$\ast$$\ast$. S\-M\-A\-C\-C translate Action server events (Result callbacks, Feedback callbacks, etc.) to statechart events. To know more about this check the sections Shared Resources and section S\-M\-A\-C\-C Architecture.
\item $\ast$$\ast$$\ast$\-Powerful access to R\-O\-S Parameters$\ast$$\ast$$\ast$. Each S\-M\-A\-C\-C state creates automatically a ros\-::\-Node\-Handle automatically named according to the S\-M\-A\-C\-C state hierarchy (see more in section Usage Examples -\/ Ros parameters)
\item $\ast$$\ast$$\ast$\-R\-O\-S Navigation built-\/in funcionality$\ast$$\ast$$\ast$. S\-M\-A\-C\-C extends in some way the navigation stack in a high level way. It provides some navigation planners (for the R\-O\-S Navigation Stack) that navigate only using pure spinning motions and stright motions. Implements some mechanism to perform motions recording the path and undoing them later. These can be very useful in some industrial applications where the knowledge or certainty on the environment is higher (ros planners are focused on cluttered and dynamic environments).
\end{DoxyItemize}

\subsection*{Repository Packages}

This repository contains several R\-O\-S packages\-:


\begin{DoxyItemize}
\item {\bfseries smacc}\-: The core smacc library. It works as a template-\/based c++ header library.
\item {\bfseries smacc\-\_\-navigation}\-: a set of ros packages with some \char`\"{}\-Smacc Components\char`\"{} that ease the creation of high level navigation applications. The provided components remotelly control the move\-\_\-base. These components helps in the creation of complex motion strategies (changing planners, recording and undoing paths, etc.)
\item {\bfseries radial\-\_\-motion\-\_\-example}\-: shows a complete sample application developed with S\-M\-A\-C\-C that can be reused as a canonical example of a mobile robot moving around and interacting with a custom onboard tool.
\item {\bfseries smacc\-\_\-tool\-\_\-plugin\-\_\-template}\-: template project that shows how an on/off tool onboard the mobile robot could be used following the S\-M\-A\-C\-C methodology.
\end{DoxyItemize}

\subsection*{Future Work}


\begin{DoxyItemize}
\item undoing paths chunks by state (store the different chunks of the path according to its state in a stack)
\item code generation based on uml diagrams
\item improving backwards planners for non linear paths
\end{DoxyItemize}

\subsection*{Shared Resources and Shared variables}


\begin{DoxyItemize}
\item $\ast$$\ast$$\ast$\-Shared Action Client Resources$\ast$$\ast$$\ast$ Action servers in S\-M\-A\-C\-C play an important role because all low-\/level funcionality must be located on them. In order to interact with these Action Servers S\-M\-A\-C\-C provide an easy way to create shared Action\-Clients that can be accessed from any State. S\-M\-A\-C\-C is in charge of eficently handle all the requests and send the resulting events from action servers (result messages, feedback messages, etc) to the \char`\"{}subscribed states\char`\"{} in form of statechart events. (See more about his in section internal architecture)
\item $\ast$$\ast$$\ast$\-Shared Variables$\ast$$\ast$$\ast$ U\-M\-L statecharts basically define the high level behavior of a system. However, in practice the real state of the system may be much more complex (mesurement, environment numerical information, etc.). States usually have to share information (or comunicate to each other). In order to do that, S\-M\-A\-C\-C implements a simple but effective dictionary-\/based mechanism to share information (structs, objects, simple variables or pointers). (See below in tutorials\-: shared variable) 
\end{DoxyItemize}

 

\subsection*{Development methodology}

S\-M\-A\-C\-C also defines a development methodology where State Machine nodes only contain the task-\/level logic, that is, the high level behavior of the robot system in some specific application.

S\-M\-A\-C\-C applications have low level coupling with other software components of the robot system. S\-M\-A\-C\-C code is recomended to interact with the rest of components the robot system via R\-O\-S Action Servers and {\bfseries Smacc Action Plugins}.

The proposed methdology split the states into 2 or more statechart orthogonal lines that comunicate to each other via events. The orthogonal line 0 is tipically for the mobile robot navigation. The second orthogonal line and ahead are used for tools (manipulators, grippers or other custom tools).

 

\subsection*{Internal Architecture}

S\-M\-A\-C\-C State Machines are boost\-::statechart Asynchronous\-State\-Machines that can work in a multi-\/threaded application. In S\-M\-A\-C\-C State Machines are two main components that work concurrently in two different threads\-:


\begin{DoxyItemize}
\item $\ast$$\ast$$\ast$\-Signal Detector$\ast$$\ast$$\ast$. It is able to handle the action client components communication with action servers and translate them to statechart events
\item $\ast$$\ast$$\ast$\-State Machine$\ast$$\ast$$\ast$. It is the end-\/user code of the state machine itself.
\end{DoxyItemize}

 

\subsection*{Executing the Radial Motion Example}

This is a complete sample of a state machine that controls the motion of a simulated ridgeback mobile robot in gazebo.

This example shows how smacc\-::\-Navigation components can be used to create some systematic motion based on an state machine. The robot performs a motion pattern that plots a \char`\"{}\-Start\char`\"{} on the plane. The state machine in the motion is combined with the usage of some external tool \char`\"{}for example ground painter\char`\"{} that is only active on forward motions.

``` export R\-I\-D\-G\-E\-B\-A\-C\-K\-\_\-\-U\-R\-D\-F\-\_\-\-E\-X\-T\-R\-A\-S=\$(rospack find radial\-\_\-motion\-\_\-example)/urdf/empty.xacro

roslaunch radial\-\_\-motion\-\_\-example radial\-\_\-motion.\-launch ``` 

      

\section*{Tutorial}

S\-M\-A\-C\-C states inherits from boost\-::statechart\-:State so that you can learn the full potential of S\-M\-A\-C\-C states also diving in the statechart documentation. However, the following examples briefly show how you create define S\-M\-A\-C\-C states and how you would usually use them.

\subsection*{Code a minimal S\-M\-A\-C\-C State\-Machine}

In this initial example we will implement a simple state machine with a single state state that executes something at state entry and at state exit. That state machine is described in the following image\-:

 

S\-M\-A\-C\-C State\-Machines and Smacc\-States are based on the c++ \href{https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern}{\tt Curiously recurring template pattern} so that the syntax may be strange for some developers but you will notice that it is very easy to follow. The advantage of using this kind of c++ pattern is that the definition of the state machine is correctly written.

The following chunk of code shows the minimal S\-M\-A\-C\-C State machine you can create\-: ```cpp \#include $<$\hyperlink{smacc__state__machine__base_8h_source}{smacc/smacc\-\_\-state\-\_\-machine\-\_\-base.\-h}$>$

struct \hyperlink{structSimpleStateMachine}{Simple\-State\-Machine} \-: public \hyperlink{structsmacc_1_1SmaccStateMachineBase}{Smacc\-State\-Machine\-Base$<$\-Simple\-State\-Machine,\-Tool\-Simple\-State$>$} \{ using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ \} \}; ```

Every S\-M\-A\-C\-C State Machine must inherit from Smacc\-State\-Machine\-Base. The first template parameter is the derived class type (\hyperlink{structSimpleStateMachine}{Simple\-State\-Machine} itself) according to the curiosuly recurring template pattern, and the second template parameter (\hyperlink{structToolSimpleState}{Tool\-Simple\-State}) would be the class name of the initial Smacc State

\subsection*{Code a simple S\-M\-A\-C\-C State}

For the previous state machine, this would be the initial S\-M\-A\-C\-C State. It also follows the Curiously recurrent template pattern. However, for Smacc states, the second template parameters is the so called \char`\"{}\-Context\char`\"{}, for this simple case, the context is the State\-Machine type itself. However, that could also be other State (in a nexted-\/substate case) or an orthogonal line.

```cpp struct \hyperlink{structToolSimpleState}{Tool\-Simple\-State} \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Tool\-Simple\-State, Simple\-State\-Machine$>$} \{ public\-:

using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ R\-O\-S\-\_\-\-I\-N\-F\-O(\char`\"{}\-Entering Tool\-Simple\-State\char`\"{}); \} \};

int main(int argc, char $\ast$$\ast$argv) \{ // initialize the ros node ros\-::init(argc, argv, \char`\"{}example1\char`\"{}); ros\-::\-Node\-Handle nh;

smacc\-::run$<$\-Simple\-State\-Machine$>$(); \} ``` According to the U\-M\-L statchart standard, things happens essencially when the system enters in the state, when the system exits the state and when some event is triggered. The two first ones are shown in this example. The c++ Constructor code is the place you have to write your \char`\"{}entry code\char`\"{}, the destructor is the place you have to write your \char`\"{}exit code\char`\"{}. The constructor parameter (my\-\_\-context) is a reference to the context object (in this case the state machine). This kind of constructor may be verebosy, but is required to implement the rest of S\-M\-A\-C\-C tasks and always follows the same pattern.

\subsection*{Creating/accessing to Smacc\-Components}

Accessing to S\-M\-A\-C\-C componets resources is one of the most important capabilities that S\-M\-A\-C\-C provides. This example shows how to access to these resources form states.

For example, in this case we will asume we are in a state that controls the navigation of the vehicle, and it needs to access to the Ros Navigation Stack Action client and navigate to some position in the environment.

 

The code would be the following\-:

```cpp struct \hyperlink{structNavigate}{Navigate} \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Navigate, Simple\-State\-Machine$>$} \{

public\-: // This is the smacc component (it basically is a wrapper of the R\-O\-S Action Client for move base), please check the S\-M\-A\-C\-C // code to see how to implement your own action client \hyperlink{classsmacc_1_1SmaccMoveBaseActionClient}{smacc\-::\-Smacc\-Move\-Base\-Action\-Client} $\ast$move\-Base\-Client\-\_\-;

using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ R\-O\-S\-\_\-\-I\-N\-F\-O(\char`\"{}\-Entering Navigate\char`\"{});

// this substate will need access to the \char`\"{}\-Move\-Base\char`\"{} resource or plugin. In this line // you get the reference to this resource. this-\/$>$requires\-Component(move\-Base\-Client\-\_\-); go\-To\-End\-Point(); \}

// auxiliar function that defines the motion that is requested to the move\-\_\-base action server void go\-To\-End\-Point() \{ geometry\-\_\-msgs\-::\-Pose\-Stamped radial\-Start\-Pose = create\-Initial\-Pose();

smacc\-::\-Smacc\-Move\-Base\-Action\-Client\-::\-Goal goal; goal.\-target\-\_\-pose.\-header.\-stamp = ros\-::\-Time\-::now();

goal.\-target\-\_\-pose = radial\-Start\-Pose; goal.\-target\-\_\-pose.\-pose.\-position.\-x = 10; goal.\-target\-\_\-pose.\-pose.\-position.\-y = 10; goal.\-target\-\_\-pose.\-pose.\-orientation = tf\-::create\-Quaternion\-Msg\-From\-Roll\-Pitch\-Yaw(0, 0, M\-\_\-\-P\-I);

move\-Base\-Client\-\_\--\/$>$send\-Goal(goal); \} \}; ```

\subsection*{Simple State Transition on Action Result Event}

According to the U\-M\-L state machines standard, transitions between states happen on events. In S\-M\-A\-C\-C events can be implemented by the user or happen when Action Results callbacks and Action Feedback callbacks happen. In the following example we extend the previous example to transit to another state '\hyperlink{structExecuteToolState}{Execute\-Tool\-State}' when the move\-\_\-base action sever returns a Result.

 

The following would be the code to implement the diagram shown above.

```cpp struct \hyperlink{structNavigate}{Navigate} \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Navigate, Simple\-State\-Machine$>$} \{ public\-:

// With this line we specify that we are going to react to any Ev\-Action\-Result event // generated by S\-M\-A\-C\-C when the action server provides a response to our request typedef mpl\-::list$<$sc\-::transition$<$Ev\-Action\-Result$<$\-Smacc\-Move\-Base\-Action\-Client\-::\-Result$>$, \hyperlink{structExecuteToolState}{Execute\-Tool\-State}$>$$>$ reactions;

using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ \mbox{[}...\mbox{]} \} \};

struct \hyperlink{structExecuteToolState}{Execute\-Tool\-State} \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Execute\-Tool\-State, Simple\-State\-Machine$>$} \{ using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ \} \}; ```

\subsection*{Add custom code on Action Result Events}

In the following example, we want to add some code to the transition between the source state \char`\"{}\-Navigate\char`\"{} and the destination state \char`\"{}\-Execute\-Tool\-State\char`\"{}. This code may be any desired custom code (for example some transition guard). This code is located in the react method

 

The following would be the code for this state machine\-:

```cpp struct \hyperlink{structNavigate}{Navigate} \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Navigate, Simple\-State\-Machine$>$} \{ public\-:

// With this line we specify that we are going to react to any Ev\-Action\-Result event // generated by S\-M\-A\-C\-C when the action server provides a response to our request typedef mpl\-::list$<$sc\-::custom\-\_\-reaction$<$Ev\-Action\-Result$<$\-Smacc\-Move\-Base\-Action\-Client\-::\-Result$>$$>$$>$ reactions; using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ \mbox{[}...\mbox{]} \}

// auxiliary function that defines the motion that is requested to the move\-\_\-base action server void go\-To\-End\-Point() \{ \mbox{[}...\mbox{]}

sc\-::result react(const Ev\-Action\-Result$<$\-Smacc\-Move\-Base\-Action\-Client\-::\-Result$>$ \&ev) \{ // we only will react when the result is succeeded if (ev.\-get\-Result() == actionlib\-::\-Simple\-Client\-Goal\-State\-::\-S\-U\-C\-C\-E\-E\-D\-E\-D) \{ // ev.\-result\-Message provides access to the move\-\_\-base action server result structure

R\-O\-S\-\_\-\-I\-N\-F\-O(\char`\"{}\-Received event to movebase\-: \%s\char`\"{},ev.\-get\-Result().to\-String().c\-\_\-str()); return transit$<$\-Execute\-Tool\-State$>$(); \} else \{ return forward\-\_\-event(); // do nothing, the default behavior if you do not specify any return value \} \} \};

struct \hyperlink{structExecuteToolState}{Execute\-Tool\-State} \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Execute\-Tool\-State, Simple\-State\-Machine$>$} \{ using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ \} \};

```

\subsection*{Adding R\-O\-S Parameters to Smacc States}

The S\-M\-A\-C\-C states can be configured from the ros parameter server based on their hierarchy and their class name. It is responsability of the user not to have two different state names at the same level (even if the namespace is distinct since the namespace is trimmed for parameters)

For example, imagine a State\-Machine to move the mobile robot initially to some initial position, and then moving it to some other position relative to the initial position. You could put the navigation parameters in a ros configuration yaml file like this (and avoid hardcoding)\-:

```yaml My\-State\-Machine\-: State1\-: \#\-Go to some initial position Navigation\-Orthogonal\-Line\-: \hyperlink{structNavigate}{Navigate}\-: start\-\_\-position\-\_\-x\-: 3 start\-\_\-position\-\_\-y\-: 0 State2\-: \#\-Go to some initial position Navigation\-Orthogonal\-Line\-: \hyperlink{structNavigate}{Navigate}\-: initial\-\_\-orientation\-\_\-index\-: 0 \# the initial index of the linear motion (factor of angle\-\_\-increment\-\_\-degrees) angle\-\_\-increment\-\_\-degree\-: 90 \# the increment of angle between to linear motions linear\-\_\-trajectories\-\_\-count\-: 2 \# the number of linear trajectories of the radial ```

Then, the c++ code for the State My\-State\-Machine/\-State1/\-Navigation\-Orthogonal\-Line/\-Navigate could contain the following parameter reading funcionality\-:

```cpp struct \hyperlink{structNavigate}{Navigate} \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Navigate, Navigation\-Orthogonal\-Line$>$} \{ public\-: using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ geometry\-\_\-msgs\-::\-Point p; param(\char`\"{}start\-\_\-position\-\_\-x\char`\"{}, p.\-x, 0); param(\char`\"{}start\-\_\-position\-\_\-y\char`\"{}, p.\-y, 0); \} \} ```

The param template method reads from the parameters server delegating to the method defined ros\-::\-Node\-Handle handle does but already located at the exact point in the parameter name hierarchy associated to this state. S\-M\-A\-C\-C is also able have methods get\-Param and set\-Param that are delegated to ros\-::\-Node\-Handle in the same way.

\subsection*{Shared variables between states}

This following example shows how to share a variable between two states. In the \hyperlink{structNavigate}{Navigate} state the \char`\"{}angle\-\_\-value\char`\"{} variable is set using the template method \char`\"{}set\-Data\char`\"{}. Latter in the \hyperlink{structExecuteToolState}{Execute\-Tool\-State} it gets the value using the template method \char`\"{}get\-Global\-S\-M\-Data\char`\"{}.

```cpp struct \hyperlink{structNavigate}{Navigate} \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Navigate, Simple\-State\-Machine$>$} \{ public\-: using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ double angle = M\-\_\-\-P\-I; this-\/$>$set\-Global\-S\-M\-Data(\char`\"{}angle\-\_\-value\char`\"{}, angle); \} \};

struct \hyperlink{structExecuteToolState}{Execute\-Tool\-State} \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Execute\-Tool\-State, Simple\-State\-Machine$>$} \{ using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ int angle; this-\/$>$get\-Global\-S\-M\-Data(\char`\"{}angle\-\_\-value\char`\"{}, angle); \} \}; ```

\subsection*{Orthogonal Lines}

S\-M\-A\-C\-C proposes to work in different orthogonal lines\-: Navigation, Tool1, Tool2, etc. This example shows how you can define orthogonal lines in your S\-M\-A\-C\-C code. For example, we want to add two orthogonal lines\-: the navigation orthogonal line and the tool orthogonal line.

 

First we will define the Navigation\-Orthogonal line line with a simple Tool\-Sub\-State\-:

```cpp struct Navigation\-Orthogonal\-Line \-: Smacc\-State$<$Navigation\-Orthogonal\-Line, Simple\-State\-Machine\-::orthogonal$<$0$>$, Navigate\-Substate$>$ \{ using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ R\-O\-S\-\_\-\-I\-N\-F\-O(\char`\"{}\-Entering in the navigation orthogonal line\char`\"{}); \}

$\sim$\-Navigation\-Orthogonal\-Line() \{ R\-O\-S\-\_\-\-I\-N\-F\-O(\char`\"{}\-Finishing the navigation orthogonal line\char`\"{}); \} \};

struct Navigate\-Substate \-: Smacc\-State$<$\-Navigate\-Substate, Navigation\-Orthogonal\-Line$>$ \{ using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ \} \};

``` First we will define the Tool\-Othogonal line with a simple Tool\-Sub\-State\-:

```cpp struct Tool\-Orthogonal\-Line \-: Smacc\-State$<$Tool\-Orthogonal\-Line, Simple\-State\-Machine\-::orthogonal$<$1$>$, Tool\-Substate$>$ \{ public\-: using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ R\-O\-S\-\_\-\-I\-N\-F\-O(\char`\"{}\-Entering in the tool orthogonal line\char`\"{}); \}

$\sim$\-Tool\-Orthogonal\-Line() \{ R\-O\-S\-\_\-\-I\-N\-F\-O(\char`\"{}\-Finishing the tool orthogonal line\char`\"{}); \} \};

struct Tool\-Substate \-: \hyperlink{classsmacc_1_1SmaccState}{Smacc\-State$<$\-Tool\-Substate, Tool\-Orthogonal\-Line$>$} \{ using Smacc\-State\-::\-Smacc\-State; void on\-Entry() \{ \} \};

``` 